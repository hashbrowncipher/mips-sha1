    
    
    
    
    
    
    
    
    
    ###read_whole_file.spp###
    ###end read_whole_file.spp###
    
    .data
    filename:
    .asciiz "input.bin"
    
    .text
    
    ################ start read_whole_file ################
    ################ start open_ro ################
    la $a0, filename
    li $a1, 0
    li $v0, 13
    
    syscall
    ################# end open_ro #################
    
    #@fd = $t0
    #@addr = $t1
    #@len = $t2
    
    
    move	$t0, $v0 # ::-> move	@fd, $v0>
    li		$t2, 0 # ::-> li		@len, 0>
    
    li		$a0, 4096
    ################ start sbrk ################
    li $v0, 9
    syscall
    ################# end sbrk #################
    
    move	$t1, $v0 # ::-> move	@addr, $v0>
    move 	$a1, $t1 # ::-> move 	$a1, @addr>
    
    move	$a0, $t0 # ::-> move	$a0, @fd>
    li		$a2, 4096
    length_loop__u0:
    ################ start read ################
    li $v0, 14
    syscall
    ################# end read #################
    addu	$t2, $t2, $v0 # ::-> addu	@len, @len, $v0>
    
    bgt		$v0, $0, length_loop__u0
    
    ################ start close ################
    li $v0, 16
    syscall
    ################# end close #################
    ################ start open_ro ################
    la $a0, filename
    li $a1, 0
    li $v0, 13
    
    syscall
    ################# end open_ro #################
    
    addi 	$a0, $t2, -4096 # ::-> addi 	$a0, @len, -4096>
    bltz	$a0, skip_sbrk__u1
    ################ start sbrk ################
    li $v0, 9
    syscall
    ################# end sbrk #################
    
    skip_sbrk__u1:
    
    move	$a0, $t0 # ::-> move	$a0, @fd>
    move	$a1, $t1 # ::-> move	$a1, @addr>
    move	$a2, $t2 # ::-> move	$a2, @len>
    ################ start read ################
    li $v0, 14
    syscall
    ################# end read #################
    
    move	$v1, $v0 #return the length
    
    ################ start close ################
    li $v0, 16
    syscall
    ################# end close #################
    
    move	$v0, $t1 #return the buffer address # ::-> move	$v0, @addr >
    ################# end read_whole_file #################
    
    beq		$v1, $0, swap_done
    
    move	$t0, $v0
    addu	$t1, $v0, $v1
    
    swap_loop:
    
    lw		$t2, 0($t0)
    
    sb		$t2, 3($t0)
    srl		$t2, $t2, 8
    
    sb		$t2, 2($t0)
    srl		$t2, $t2, 8
    
    sb		$t2, 1($t0)
    srl		$t2, $t2, 8
    
    sb		$t2, 0($t0)
    
    addi	$t0, $t0, 4
    bgt		$t1, $t0, swap_loop
    
    swap_done:
    
    move	$a0, $v0
    srl		$a1, $v1, 29	#load the top three bits into hlength
    sll		$a2, $v1, 3		#load the bottom 29 bits into llength
    
    la		$ra, hashing_done
    j		sha1
    hashing_done:
    
    addiu	$s0, $sp, -4
    sb		$0, 0($s0)
    
    li		$s1, 15
    
    ################ start hexify ################
    #	@string = $s0
    #	@mask = $s1
    #	@trimmed = $s2
    #	@flag = $s3
    #	@count = $s4
    
    li		$s4, 8 # ::-> li		@count, 8>
    
    loop__u2:
    addi	$s4, $s4, -1 # ::-> addi	@count, @count, -1>
    addi	$s0, $s0, -1 # ::-> addi	@string, @string, -1>
    
    and		$s2, $t4, $s1 # ::-> and		@trimmed, $t4, @mask>
    slti	$s3, $s2, 10 # ::-> slti	@flag, @trimmed, 10>
    bne		$s3, $0, skip_add__u3 # ::-> bne		@flag, $0, skip_add__u3>
    addi	$s2, $s2, 7 # ::-> addi	@trimmed, @trimmed, 7>
    skip_add__u3:
    addi	$s2, $s2, 48 # ::-> addi	@trimmed, @trimmed, 48>
    sb		$s2, 0($s0) # ::-> sb		@trimmed, 0(@string)>
    
    srl		$t4, $t4, 4
    bne		$s4, $0, loop__u2 # ::-> bne		@count, $0, loop__u2>
    ################# end hexify #################
    ################ start hexify ################
    #	@string = $s0
    #	@mask = $s1
    #	@trimmed = $s2
    #	@flag = $s3
    #	@count = $s4
    
    li		$s4, 8 # ::-> li		@count, 8>
    
    loop__u4:
    addi	$s4, $s4, -1 # ::-> addi	@count, @count, -1>
    addi	$s0, $s0, -1 # ::-> addi	@string, @string, -1>
    
    and		$s2, $t3, $s1 # ::-> and		@trimmed, $t3, @mask>
    slti	$s3, $s2, 10 # ::-> slti	@flag, @trimmed, 10>
    bne		$s3, $0, skip_add__u5 # ::-> bne		@flag, $0, skip_add__u5>
    addi	$s2, $s2, 7 # ::-> addi	@trimmed, @trimmed, 7>
    skip_add__u5:
    addi	$s2, $s2, 48 # ::-> addi	@trimmed, @trimmed, 48>
    sb		$s2, 0($s0) # ::-> sb		@trimmed, 0(@string)>
    
    srl		$t3, $t3, 4
    bne		$s4, $0, loop__u4 # ::-> bne		@count, $0, loop__u4>
    ################# end hexify #################
    ################ start hexify ################
    #	@string = $s0
    #	@mask = $s1
    #	@trimmed = $s2
    #	@flag = $s3
    #	@count = $s4
    
    li		$s4, 8 # ::-> li		@count, 8>
    
    loop__u6:
    addi	$s4, $s4, -1 # ::-> addi	@count, @count, -1>
    addi	$s0, $s0, -1 # ::-> addi	@string, @string, -1>
    
    and		$s2, $t2, $s1 # ::-> and		@trimmed, $t2, @mask>
    slti	$s3, $s2, 10 # ::-> slti	@flag, @trimmed, 10>
    bne		$s3, $0, skip_add__u7 # ::-> bne		@flag, $0, skip_add__u7>
    addi	$s2, $s2, 7 # ::-> addi	@trimmed, @trimmed, 7>
    skip_add__u7:
    addi	$s2, $s2, 48 # ::-> addi	@trimmed, @trimmed, 48>
    sb		$s2, 0($s0) # ::-> sb		@trimmed, 0(@string)>
    
    srl		$t2, $t2, 4
    bne		$s4, $0, loop__u6 # ::-> bne		@count, $0, loop__u6>
    ################# end hexify #################
    ################ start hexify ################
    #	@string = $s0
    #	@mask = $s1
    #	@trimmed = $s2
    #	@flag = $s3
    #	@count = $s4
    
    li		$s4, 8 # ::-> li		@count, 8>
    
    loop__u8:
    addi	$s4, $s4, -1 # ::-> addi	@count, @count, -1>
    addi	$s0, $s0, -1 # ::-> addi	@string, @string, -1>
    
    and		$s2, $t1, $s1 # ::-> and		@trimmed, $t1, @mask>
    slti	$s3, $s2, 10 # ::-> slti	@flag, @trimmed, 10>
    bne		$s3, $0, skip_add__u9 # ::-> bne		@flag, $0, skip_add__u9>
    addi	$s2, $s2, 7 # ::-> addi	@trimmed, @trimmed, 7>
    skip_add__u9:
    addi	$s2, $s2, 48 # ::-> addi	@trimmed, @trimmed, 48>
    sb		$s2, 0($s0) # ::-> sb		@trimmed, 0(@string)>
    
    srl		$t1, $t1, 4
    bne		$s4, $0, loop__u8 # ::-> bne		@count, $0, loop__u8>
    ################# end hexify #################
    ################ start hexify ################
    #	@string = $s0
    #	@mask = $s1
    #	@trimmed = $s2
    #	@flag = $s3
    #	@count = $s4
    
    li		$s4, 8 # ::-> li		@count, 8>
    
    loop__u10:
    addi	$s4, $s4, -1 # ::-> addi	@count, @count, -1>
    addi	$s0, $s0, -1 # ::-> addi	@string, @string, -1>
    
    and		$s2, $t0, $s1 # ::-> and		@trimmed, $t0, @mask>
    slti	$s3, $s2, 10 # ::-> slti	@flag, @trimmed, 10>
    bne		$s3, $0, skip_add__u11 # ::-> bne		@flag, $0, skip_add__u11>
    addi	$s2, $s2, 7 # ::-> addi	@trimmed, @trimmed, 7>
    skip_add__u11:
    addi	$s2, $s2, 48 # ::-> addi	@trimmed, @trimmed, 48>
    sb		$s2, 0($s0) # ::-> sb		@trimmed, 0(@string)>
    
    srl		$t0, $t0, 4
    bne		$s4, $0, loop__u10 # ::-> bne		@count, $0, loop__u10>
    ################# end hexify #################
    
    move	$a0, $s0
    ################ start print_string ################
    li	$v0, 4
    syscall
    ################# end print_string #################
    
    ################ start exit ################
    li $v0, 10
    syscall
    ################# end exit #################
    
    
    ###sha1.spp###
    
    ###sha1_do_block.spp###
    sha1_do_block:
    addiu	$sp, $sp, -320
    
    #@chunk = $a0
    #@data = $a1
    #@h0 = $t0
    #@h1 = $t1
    #@h2 = $t2
    #@h3 = $t3
    #@h4 = $t4
    
    #1. Prepare the message schedule
    
    #W_t(i) = M_t(i) where 0 ≤ t ≤ 15
    
    lw $a1, 0($a0)         #copy the chunk into stack memory, because we're gonna be extending it # ::-> lw @data, 0(@chunk)
    sw $a1, 0($sp) # ::-> sw @data, 0($sp)
    
    lw $a1, 4($a0) # ::-> lw @data, 4(@chunk)
    sw $a1, 4($sp) # ::-> sw @data, 4($sp)
    
    lw $a1, 8($a0) # ::-> lw @data, 8(@chunk)
    sw $a1, 8($sp) # ::-> sw @data, 8($sp)
    
    lw $a1, 12($a0) # ::-> lw @data, 12(@chunk)
    sw $a1, 12($sp) # ::-> sw @data, 12($sp)
    
    lw $a1, 16($a0) # ::-> lw @data, 16(@chunk)
    sw $a1, 16($sp) # ::-> sw @data, 16($sp)
    
    lw $a1, 20($a0) # ::-> lw @data, 20(@chunk)
    sw $a1, 20($sp) # ::-> sw @data, 20($sp)
    
    lw $a1, 24($a0) # ::-> lw @data, 24(@chunk)
    sw $a1, 24($sp) # ::-> sw @data, 24($sp)
    
    lw $a1, 28($a0) # ::-> lw @data, 28(@chunk)
    sw $a1, 28($sp) # ::-> sw @data, 28($sp)
    
    lw $a1, 32($a0) # ::-> lw @data, 32(@chunk)
    sw $a1, 32($sp) # ::-> sw @data, 32($sp)
    
    lw $a1, 36($a0) # ::-> lw @data, 36(@chunk)
    sw $a1, 36($sp) # ::-> sw @data, 36($sp)
    
    lw $a1, 40($a0) # ::-> lw @data, 40(@chunk)
    sw $a1, 40($sp) # ::-> sw @data, 40($sp)
    
    lw $a1, 44($a0) # ::-> lw @data, 44(@chunk)
    sw $a1, 44($sp) # ::-> sw @data, 44($sp)
    
    lw $a1, 48($a0) # ::-> lw @data, 48(@chunk)
    sw $a1, 48($sp) # ::-> sw @data, 48($sp)
    
    lw $a1, 52($a0) # ::-> lw @data, 52(@chunk)
    sw $a1, 52($sp) # ::-> sw @data, 52($sp)
    
    lw $a1, 56($a0) # ::-> lw @data, 56(@chunk)
    sw $a1, 56($sp) # ::-> sw @data, 56($sp)
    
    lw $a1, 60($a0) # ::-> lw @data, 60(@chunk)
    sw $a1, 60($sp) # ::-> sw @data, 60($sp)
    
    #@temp = $t5
    #@w = $t6
    #@i = $t7
    #@limit = $s0
    
    #W_t(i) = ROTL_1(W[t−3] ⊕ W[t−8] ⊕ W[t−14] ⊕ W[t−16]) where 16 ≤ t ≤ 79
    
    addiu $t7, $sp, 64           #16 words == 64 bytes # ::-> addiu @i, $sp, 64
    addiu $s0, $sp, 320      #80 words == 320 bytes # ::-> addiu @limit, $sp, 320
    
    extend_loop__u12:                #extend the message schedule
    lw      $t6, -12($t7) # ::-> lw      @w, -12(@i)
    lw      $t5, -32($t7) # ::-> lw      @temp, -32(@i)
    xor     $t6, $t6, $t5 # ::-> xor     @w, @w, @temp
    lw      $t5, -56($t7) # ::-> lw      @temp, -56(@i)
    xor     $t6, $t6, $t5 # ::-> xor     @w, @w, @temp
    lw      $t5, -64($t7) # ::-> lw      @temp, -64(@i)
    xor     $t6, $t6, $t5 # ::-> xor     @w, @w, @temp
    
    srl     $t5, $t6, 31		#leftrotate @w by 1 # ::-> srl     @temp, @w, 31
    sll     $t6, $t6, 1 # ::-> sll     @w, @w, 1
    or      $t6, $t6, $t5 # ::-> or      @w, @w, @temp
    sw      $t6, 0($t7) # ::-> sw      @w, 0(@i)
    
    addiu   $t7, $t7, 4 # ::-> addiu   @i, @i, 4
    blt		$t7, $s0, extend_loop__u12 # ::-> blt		@i, @limit, extend_loop__u12
    
    # 2. Initialize the five working variables, a, b, c, d, and e, with the (i-1)st hash value:
    
    #@a = $s1
    #@b = $s2
    #@c = $s3
    #@d = $s4
    #@e = $s5
    
    move    $s1, $t0 # ::-> move    @a, @h0
    move    $s2, $t1 # ::-> move    @b, @h1
    move    $s3, $t2 # ::-> move    @c, @h2
    move    $s4, $t3 # ::-> move    @d, @h3
    move    $s5, $t4 # ::-> move    @e, @h4
    
    # 3. For t=0 to 79:
    # {
    # T = ROTL_5(a) + f_t(b, c, d) + e + K_t + W_t
    # e = d
    # d = c
    # c = ROTL 30 (b )
    # b = a
    # a = T
    # }
    
    li      $t7, 0 # ::-> li      @i, 0
    
    confuse_loop__u13:
    
    #cases for computing f_t(b, c, d) + K_t
    addiu   $t5, $t7, -80      # 0 ≤ i ≤ 19 # ::-> addiu   @temp, @i, -80
    bltz    $t5, case0__u14 # ::-> bltz    @temp, case0__u14
    
    addiu   $t5, $t5, -80      # 20 ≤ i ≤ 39 # ::-> addiu   @temp, @temp, -80
    bltz    $t5, case20__u15 # ::-> bltz    @temp, case20__u15
    
    addiu   $t5, $t5, -80      # 40 ≤ i ≤ 59 # ::-> addiu   @temp, @temp, -80
    bltz    $t5, case40__u16 # ::-> bltz    @temp, case40__u16
    
    j       case60__u17              # 60 ≤ i ≤ 79
    
    #@f = $s6
    
    case0__u14:
    #Ch(b, c, d) = (b ∧ c) ⊕ ( ¬ b ∧ d)
    
    
    and     $s6, $s2, $s3          #@f    CONTAINS b ∧ c # ::-> and     @f, @b, @c
    nor     $t5, $s2, $0       #@temp CONTAINS ¬ b # ::-> nor     @temp, @b, $0
    and     $t5, $t5, $s4    #@temp CONTAINS ¬ b ∧ d # ::-> and     @temp, @temp, @d
    xor     $s6, $s6, $t5       #@f    CONTAINS (b ∧ c) ⊕ (¬ b ∧ d) # ::-> xor     @f, @f, @temp
    
    li      $t5, 0x5A827999 # ::-> li      @temp, 0x5A827999
    addu    $s6, $s6, $t5 # ::-> addu    @f, @f, @temp
    
    j       end_case__u18
    case20__u15:
    #Parity(b, c, d) = b ⊕ c ⊕ d
    
    xor     $s6, $s2, $s3 # ::-> xor     @f, @b, @c
    xor     $s6, $s6, $s4 # ::-> xor     @f, @f, @d
    
    li      $t5, 0x6ED9EBA1 # ::-> li      @temp, 0x6ED9EBA1
    addu    $s6, $s6, $t5 # ::-> addu    @f, @f, @temp
    
    j       end_case__u18
    case40__u16:
    #Maj(b, c, d) = (b ∧ c) ⊕ (b ∧ d) ⊕ (c ∧ d)
    
    and     $s6, $s2, $s3 # ::-> and     @f, @b, @c
    and     $t5, $s2, $s4 # ::-> and     @temp, @b, @d
    xor     $s6, $s6, $t5 # ::-> xor     @f, @f, @temp
    
    and     $t5, $s3, $s4 # ::-> and     @temp, @c, @d
    xor     $s6, $s6, $t5 # ::-> xor     @f, @f, @temp
    
    li      $t5, 0x8F1BBCDC # ::-> li      @temp, 0x8F1BBCDC
    addu    $s6, $s6, $t5 # ::-> addu    @f, @f, @temp
    
    j       end_case__u18
    case60__u17:
    #Parity(b, c, d) = b ⊕ c ⊕ d
    
    xor     $s6, $s2, $s3 # ::-> xor     @f, @b, @c
    xor     $s6, $s6, $s4 # ::-> xor     @f, @f, @d
    
    li      $t5, 0xCA62C1D6  # ::-> li      @temp, 0xCA62C1D6
    addu    $s6, $s6, $t5 # ::-> addu    @f, @f, @temp
    
    end_case__u18:
    
    addu    $s6, $s6, $s5              #@f CONTAINS f_t(b, c, d) + e + K_t # ::-> addu    @f, @f, @e
    
    
    #TODO: Do I really need to use $at?
    
    sll     $t5, $s1, 5 # ::-> sll     @temp, @a, 5
    srl     $at, $s1, 27 # ::-> srl     $at, @a, 27
    or      $t5, $t5, $at       #@temp CONTAINS ROTL_5(a) # ::-> or      @temp, @temp, $at
    
    addu    $at, $sp, $t7           #compute location of w[i] # ::-> addu    $at, $sp, @i
    lw      $at, 0($at)             #load w[i] into $at
    
    addu    $t5, $t5, $at       #@temp CONTAINS ROTL_5(a) + w[i] # ::-> addu    @temp, @temp, $at
    addu    $t5, $t5, $s6        #add @f to @temp.  @f is now free for whatever use we need. # ::-> addu    @temp, @temp, @f
    
    move    $s5, $s4 # ::-> move    @e, @d
    move    $s4, $s3 # ::-> move    @d, @c
    
    sll     $s6, $s2, 30              #@f is now free, remember? # ::-> sll     @f, @b, 30
    srl     $s3, $s2, 2 # ::-> srl     @c, @b, 2
    or      $s3, $s3, $s6 # ::-> or      @c, @c, @f
    
    move    $s2, $s1 # ::-> move    @b, @a
    move    $s1, $t5 # ::-> move    @a, @temp
    
    addiu   $t7, $t7, 4 # ::-> addiu   @i, @i, 4
    
    #If i<80, we're not done yet.  Go back to the top of confuse_loop__u13
    addiu   $t5, $t7, -320         #80 words == 320 bytes # ::-> addiu   @temp, @i, -320
    bltz    $t5, confuse_loop__u13 # ::-> bltz    @temp, confuse_loop__u13
    
    addu    $t0, $t0, $s1 # ::-> addu    @h0, @h0, @a
    addu    $t1, $t1, $s2 # ::-> addu    @h1, @h1, @b
    addu    $t2, $t2, $s3 # ::-> addu    @h2, @h2, @c
    addu    $t3, $t3, $s4 # ::-> addu    @h3, @h3, @d
    addu    $t4, $t4, $s5 # ::-> addu    @h4, @h4, @e
    
    addiu	$sp, $sp, 320
    
    jr		$ra
    ###end sha1_do_block.spp###
    
    
    
    
    
    
    
    sha1:
    sw		$ra, -4($sp)
    sw		$fp, -8($sp)
    addiu	$fp, $sp, -8
    addiu	$sp, $fp, -160		#Allocate myself 8 words + 2 * 512 bits = 160 bytes on the stack
    
    ################ start sha1_init ################
    #pointer to message
    #@message = $a0
    #length of message in bits, high part
    #@hlength = $a1
    #length of message in bits, low part
    #@llength = $a2
    
    sll     $t0, $a0, 30       #$t0 CONTAINS 0 if the message is word aligned # ::-> sll     $t0, @message, 30       >
    sltu    $v0, $0, $t0			#If not word aligned, set error code
    bne     $v0, $0, sha1_end			#Give up if not word aligned
    
    sw 		$s7, -4($fp)
    sw		$s6, -8($fp)
    sw		$s5, -12($fp)
    sw		$s4, -16($fp)
    sw		$s3, -20($fp)
    sw		$s2, -24($fp)
    sw		$s1, -28($fp)
    sw		$s0, -32($fp)
    
    sw		$a2, -36($fp)		#We can go ahead and store the length on the stack now
    sw		$a1, -40($fp)
    
    sll     $a1, $a1, 23 # ::-> sll     @hlength, @hlength, 23>
    srl		$t0, $a2, 9 # ::-> srl		$t0, @llength, 9>
    or      $a1, $a1, $t0 # ::-> or      @hlength, @hlength, $t0>
    sll		$a1, $a1, 6 # ::-> sll		@hlength, @hlength, 6>
    addu	$a1, $a1, $a0	#We are now using $a1 to store the location of the last block # ::-> addu	@hlength, @hlength, @message	>
    
    sll		$a2, $a2, 23 # ::-> sll		@llength, @llength, 23>
    srl		$a2, $a2, 23			#and we are using $a2 to store the bits count in the last block # ::-> srl		@llength, @llength, 23			>
    
    sltiu	$t0, $a2, 448				#If we have fewer than 448 bits, then we can give 512 bits of stack back # ::-> sltiu	$t0, @llength, 448				>
    sll		$t0, $t0, 6
    addu	$sp, $sp, $t0
    ################# end sha1_init #################
    ################ start sha1_copy ################
    #@message	= $a0
    #@last		= $a1
    #@bits		= $a2
    
    #@dstitr  = $t0
    #@srcitr  = $t1
    #@limit   = $t2
    #@temp	 = $t3
    
    beq		$a2, $0, copy_done__u20		#Skip copying if we have no extra bits laying around # ::-> beq		@bits, $0, copy_done__u20		>
    
    add		$t0, $sp, 40			#This allows us to stop writing at @dstitr == -40($fp) # ::-> add		@dstitr, $sp, 40			>
    move	$t1, $a1 # ::-> move	@srcitr, @last>
    move	$t2, $a2 # ::-> move	@limit, @bits>
    
    copy_loop__u19:
    lw		$t3, 0($t1) # ::-> lw		@temp, 0(@srcitr)>
    sw		$t3, -40($t0) # ::-> sw		@temp, -40(@dstitr)>
    addi	$t2, $t2, -32 # ::-> addi	@limit, @limit, -32>
    addi	$t1, $t1, 4 # ::-> addi	@srcitr, @srcitr, 4>
    addi	$t0, $t0, 4 # ::-> addi	@dstitr, @dstitr, 4>
    bgtz	$t2, copy_loop__u19 # ::-> bgtz	@limit, copy_loop__u19>
    
    copy_done__u20:
    beq		$t0, $fp, zero_done__u22 # ::-> beq		@dstitr, $fp, zero_done__u22>
    
    zero_loop__u21:
    sw		$0, -40($t0) # ::-> sw		$0, -40(@dstitr)>
    addi	$t0, $t0, 4 # ::-> addi	@dstitr, @dstitr, 4>
    bne		$t0, $fp, zero_loop__u21 # ::-> bne		@dstitr, $fp, zero_loop__u21>
    
    zero_done__u22:
    ################# end sha1_copy #################
    ################ start sha1_pad ################
    #@bits		= $a2
    #@pad_addr	= $t0
    #@pad_data	= $t1
    #@pad_temp	= $t2
    
    srl		$t0, $a2, 5			#Divide bits by 32 to get the word # ::-> srl		@pad_addr, @bits, 5			>
    sll		$t0, $t0, 2			#Multiply by 4 to get the number of bytes # ::-> sll		@pad_addr, @pad_addr, 2			>
    addu	$t0, $t0, $sp		#Position of the word where the message ends # ::-> addu	@pad_addr, @pad_addr, $sp		>
    
    sll		$a2, $a2, 27 # ::-> sll		@bits, @bits, 27>
    srl		$a2, $a2, 27 # ::-> srl		@bits, @bits, 27>
    
    lw		$t1, 0($t0) # ::-> lw		@pad_data, 0(@pad_addr)>
    
    lui		$t2, 0x8000 # ::-> lui		@pad_temp, 0x8000>
    srlv	$t2, $t2, $a2 # ::-> srlv	@pad_temp, @pad_temp, @bits>
    or		$t1, $t1, $t2		#Pad with a 1 bit # ::-> or		@pad_data, @pad_data, @pad_temp		>
    
    lui		$t2, 0x8000 # ::-> lui		@pad_temp, 0x8000>
    srav	$t2, $t2, $a2 # ::-> srav	@pad_temp, @pad_temp, @bits>
    and		$t1, $t1, $t2		#Zero all of the other bits in the word # ::-> and		@pad_data, @pad_data, @pad_temp		>
    
    sw		$t1, 0($t0) # ::-> sw		@pad_data, 0(@pad_addr)>
    ################# end sha1_pad #################
    
    li		$t0, 0x67452301
    li		$t1, 0xEFCDAB89
    li		$t2, 0x98BADCFE
    li		$t3, 0x10325476
    li		$t4, 0xC3D2E1F0
    
    #	@message	= $a0
    #	@last		= $a1
    #	@temp		= $t5
    
    beq		$a0, $a1, sha1_process_last_blocks # ::-> beq		@message, @last, sha1_process_last_blocks
    
    la		$ra, sha1_do_block_return1
    j		sha1_do_block
    
    sha1_do_block_return1:
    addiu	$a0, $a0, 64 # ::-> addiu	@message, @message, 64
    bne		$a0, $a1, sha1_do_block # ::-> bne		@message, @last, sha1_do_block
    
    sha1_process_last_blocks:
    move	$a0, $sp # ::-> move	@message, $sp
    la		$ra, sha1_do_block_return2
    j		sha1_do_block
    
    sha1_do_block_return2:
    addiu	$a0, $a0, 64 # ::-> addiu	@message, @message, 64
    addiu	$t5, $a0, 32 # ::-> addiu	@temp, @message, 32
    bne		$t5, $fp, sha1_do_block # ::-> bne		@temp, $fp, sha1_do_block
    
    sha1_end:
    lw		$ra, 4($fp)
    move	$sp, $fp
    lw		$fp, 0($fp)
    
    jr		$ra
    ###end sha1.spp###
    